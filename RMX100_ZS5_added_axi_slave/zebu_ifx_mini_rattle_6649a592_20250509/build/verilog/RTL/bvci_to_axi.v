// Library ARC_Soc_Trace-1.0.999999999
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2003-2007 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
//
// ARC Product:  @@PRODUCT_NAME@@ v@@VERSION_NUMBER@@
// File version: $Revision$
// ARC Chip ID:  %%System.chipId%%
//
// Description:
//
// --------------------------------------------------------------- //
// The "bvci_to_axi" bridge serves two functions:                  //
//                                                                 //
// 1) It converts the BVCI initiator to AXI master protocol        //
// 2) It Registers all outputs                                     //
//                                                                 //
// The bvci-to-axi bridge is not a general purpose BVCI to AXI     //
// protocol converter and only caters for the type of transactions //
// that may be generated by the Island BVCI initiators.            //
// --------------------------------------------------------------- //
// --------------------------------------------------------------- //
// Input and output signals:                                       //
//                                                                 //
// Miscellaneous inputs:                                           //
//                                                                 //
// clk       : in  : module clock signal (aclk)                    //
// rst_n     : in  : module reset signal (~aresetn)                //
// sync      : in  : Synchronization signal                        //
//                                                                 //
// BVCI port inputs:                                               //
//                                                                 //
// t_address : in  : BVCI address [31:0]                           //
// t_be      : in  : BVCI byte enables [7/3:0]                     //
// t_cmd     : in  : BVCI command [1:0]                            //
// t_eop     : in  : BVCI end of packet                            //
// t_plen    : in  : BVCI packet length [8:0] (in bytes)           //
// t_wdata   : in  : BVCI write data [63/31:0]                     //
// t_cmdval  : in  : BVCI command valid                            //
//                                                                 //
// AXI protocol port inputs:                                       //
//                                                                 //
// awready   : in  : AXI write address ready                       //
// wready    : in  : AXI write ready                               //
// bid       : in  : AXI write response id [3:0]                   //
// bresp     : in  : AXI write response [1:0]                      //
// bvalid    : in  : AXI write response valid                      //
// arready   : in  : AXI read address ready                        //
// rid       : in  : AXI read id [3:0]                             //
// rdata     : in  : AXI read data [31:0]                          //
// rlast     : in  : AXI read last                                 //
// rvalid    : in  : AXI read valid                                //
// rresp     : in  : AXI read response                             //
//                                                                 //
// BVCI port outputs:                                              //
//                                                                 //
// t_cmdack  : out : BVCI command acknowledge                      //
// t_rdata   : out : BVCI read data [63/31:0]                      //
// t_reop    : out : BVCI response to end of packet                //
// t_rspval  : out : BVCI response valid                           //
// t_rerror  : out : BVCI error                                    //
//                                                                 //
// AXI protocol port outputs:                                      //
//                                                                 //
// awid      : out : AXI write address id [3:0]                    //
// awaddr    : out : AXI write address [31:0]                      //
// awlen     : out : AXI write address burst length [3:0]          //
// awsize    : out : AXI write address burst transfer size [2:0]   //
// awburst   : out : AXI write address burst type [1:0]            //
// awlock    : out : AXI write address lock type [1:0]             //
// awcache   : out : AXI write address cache type [3:0]            //
// awprot    : out : AXI write address protection type [2:0]       //
// awvalid   : out : AXI write address valid                       //
// wid       : out : AXI write id [3:0]                            //
// wdata     : out : AXI write data [31:0]                         //
// wstrb     : out : AXI write strobe [3:0]                        //
// wlast     : out : AXI write last                                //
// wvalid    : out : AXI write valid                               //
// bready    : out : AXI write response ready                      //
// arid      : out : AXI read address id [3:0]                     //
// araddr    : out : AXI read address [31:0]                       //
// arlen     : out : AXI read burst length [3:0]                   //
// arsize    : out : AXI read burst transfer size [2:0]            //
// arburst   : out : AXI write address burst type [1:0]            //
// arlock    : out : AXI read lock type [1:0]                      //
// arcache   : out : AXI read cache type [3:0]                     //
// arprot    : out : AXI read protection type [2:0]                //
// arvalid   : out : AXI read address valid                        //
// rready    : out : AXI read ready                                //
//                                                                 //
// Miscellaneous outputs:                                          //
//                                                                 //
// busy      : out : indicates if the bridge is in idle state      //
//                                                                 //
// --------------------------------------------------------------- //
`include "dw_dbp_defines.v"
`include "defines.v"
//`include "%%unique_name%%bus_defs.v"
module bvci_to_axi(
  select_in,
  clk,
  rst_a,
  sync,
  t_address,
  t_be,
  t_cmd,
  t_eop,
  t_plen,
  t_wdata,
  t_cmdval,
  bri_awready,
  bri_wready,
  bri_bid,
  bri_bresp,
  bri_bvalid,
  bri_arready,
  bri_rid,
  bri_rdata,
  bri_rlast,
  bri_rvalid,
  bri_rresp,
  t_cmdack,
  t_rdata,
  t_reop,
  t_rspval,
  t_rerror,
  bri_awid,
  bri_awaddr,
  bri_awlen,
  bri_awsize,
  bri_awburst,
  bri_awlock,
  bri_awcache,
  bri_awprot,
  bri_awvalid,
  bri_wid,
  bri_wdata,
  bri_wstrb,
  bri_wlast,
  bri_wvalid,
  bri_bready,
  bri_arid,
  bri_araddr,
  bri_arlen,
  bri_arsize,
  bri_arburst,
  bri_arlock,
  bri_arcache,
  bri_arprot,
  bri_arvalid,
  bri_rready,
  bri_busy);

// Bridge identification tag:
//
// 4'b 0001 = ARC600 Island
//
parameter ID_TAG     = 4'b 0001;

// module inputs
//
input  [31:0]                select_in;
input                        clk;
input                        rst_a;
input                        sync;
input  [32-1:0]      t_address;
//ARCPRAGMA little_endian_be_order START %%!big_endian%%
input  [(32/8)-1:0]  t_be;
//ARCPRAGMA little_endian_be_order END
//ARCPRAGMA big_endian_be_order START %%big_endian%%
//input  [0:(32/8)-1]  t_be;
//ARCPRAGMA big_endian_be_order END
input  [2-1:0]       t_cmd;
input                        t_eop;
input  [9-1:0]      t_plen;
input  [32-1:0]      t_wdata;
input                        t_cmdval;
input                        bri_awready;
input                        bri_wready;
input  [4-1:0]        bri_bid;
input  [2-1:0]       bri_bresp;
input                        bri_bvalid;
input                        bri_arready;
input  [4-1:0]        bri_rid;
input  [32-1:0]       bri_rdata;
input                        bri_rlast;
input                        bri_rvalid;
input  [2-1:0]       bri_rresp;

// module outputs
//
output                       t_cmdack;
output [32-1:0]      t_rdata;
output                       t_reop;
output                       t_rspval;
output                       t_rerror;
output [4-1:0]        bri_awid;
output [32-1:0]       bri_awaddr;
output [4-1:0]        bri_awlen;
output [3-1:0]       bri_awsize;
output [2-1:0]      bri_awburst;
output [2-1:0]       bri_awlock;
output [4-1:0]      bri_awcache;
output [3-1:0]       bri_awprot;
output                       bri_awvalid;
output [4-1:0]        bri_wid;
output [32-1:0]       bri_wdata;
output [(32/8)-1:0]   bri_wstrb;
output                       bri_wlast;
output                       bri_wvalid;
output                       bri_bready;
output [4-1:0]        bri_arid;
output [32-1:0]       bri_araddr;
output [4-1:0]        bri_arlen;
output [3-1:0]       bri_arsize;
output [2-1:0]      bri_arburst;
output [2-1:0]       bri_arlock;
output [4-1:0]      bri_arcache;
output [3-1:0]       bri_arprot;
output                       bri_arvalid;
output                       bri_rready;
output                       bri_busy;
/////////////////////////////////////////////////////
//`define AXI_ROM_SPACE 20'hFFFF8 //20001
//`define AXI_ROM_BASE_ADDR 32'hFFFF8000 //20001000
//`define AXI_AP_REG_SPACE 20'hFFFF7

localparam DB_STATUS =  32'hFFFF7000; //20000000;
localparam DB_DATA =  32'hFFFF700c; //2000000c;
localparam DB_CMD  = 32'hFFFF7004; //20000004;
localparam DB_ADDR  = 32'hFFFF7008; //20000008;

localparam AXI_STATUS =  12'h000; 
localparam AXI_DATA =  12'h00c; 
localparam AXI_CMD  = 12'h004; 
localparam AXI_ADDR  = 12'h008; 
localparam AXI_RESET =12'h010;

localparam AXI_CSR1 =  12'h400;
localparam AXI_CSR2 =  12'h404;
localparam AXI_CSR3 =  12'h408;
localparam AXI_CSR4 =  12'h40c;
localparam AXI_CSR5 =  12'h410;

/////////////////select division//////////
localparam my_bits = 4;
//reg [31:0] select_in =32'b0;

wire [my_bits-1:0] my_select = select_in[my_bits-1:0];

// Select for non-leaf kid: strip off my bits.
wire [31:0] next_select =  select_in >> my_bits;
/////////////////////////////////////////
reg bvci_read;
reg bvci_write;
reg [31:0] axiap_rdata;
wire axi_rerr;
wire axi_reop;
wire axi_cmdack, axi_rspval;
wire [31:0] i_axi_data;

reg [32-1:0] axi_addr_nxt;
reg [32-1:0] axi_data_nxt;
reg [32-1:0] axi_cmd_nxt;
//reg axi_rom_sel_nxt;

reg [32-1:0] axi_addr;
reg [32-1:0] axi_data;
reg [32-1:0] axi_cmd ;
//reg axi_rom_sel;
reg [32-1:0] rom_rdata;
///////////////////////////////////////////////

// output wires
//
wire                         t_cmdack;
wire   [32-1:0]      t_rdata;
wire                         t_reop;
wire                         t_rspval;
wire                         t_rerror;
wire   [4-1:0]        bri_awid;
wire   [32-1:0]       bri_awaddr;
wire   [4-1:0]        bri_awlen;
wire   [3-1:0]       bri_awsize;
wire   [2-1:0]      bri_awburst;
wire   [2-1:0]       bri_awlock;
wire   [4-1:0]      bri_awcache;
wire   [3-1:0]       bri_awprot;
wire                         bri_awvalid;
wire   [4-1:0]        bri_wid;
wire   [32-1:0]       bri_wdata;
wire   [(32/8)-1:0]   bri_wstrb;
wire                         bri_wlast;
wire                         bri_wvalid;
wire                         bri_bready;
wire   [4-1:0]        bri_arid;
wire   [32-1:0]       bri_araddr;
wire   [4-1:0]        bri_arlen;
wire   [3-1:0]       bri_arsize;
wire   [2-1:0]      bri_arburst;
wire   [2-1:0]       bri_arlock;
wire   [4-1:0]      bri_arcache;
wire   [3-1:0]       bri_arprot;
wire                         bri_arvalid;
wire                         bri_rready;
wire                         bri_busy;

wire   [32-1:0]      i_axi_raddr_a;
wire                         i_odd16_a;
// Internal signals have the "i_" prefix. This should not be
// confused with "i_" prefix that is sometimes used for BVCI 
// initiator signals. There are no BVCI initiator signals in this
// module.

//  AXI specific signals
//
wire   [4-1:0]        i_axi_len_a;
wire   [3-1:0]       i_axi_size_a;
wire   [3-1:0]       i_axi_rsize_a;
wire   [2-1:0]      i_axi_burst_a;
wire   [4-1:0]      i_axi_cache_a;
wire   [2-1:0]       i_axi_lock_a;
wire   [3-1:0]       i_axi_prot_a;
wire   [4-1:0]        i_axi_id_a;
wire                         i_axi_write_a;

// BVCI specific signals
//
wire                         i_bvci_cmd_a;
wire   [3:0]                 i_length_a;

// AXI registers
//
//reg  [32-1:0]       i_bri_rdata;
reg    [32-1:0]       i_awaddr_nxt;
reg    [32-1:0]       i_awaddr_r;
reg    [4-1:0]        i_awlen_nxt;
reg    [4-1:0]        i_awlen_r;
reg    [3-1:0]       i_awsize_nxt;
reg    [3-1:0]       i_awsize_r;
reg    [2-1:0]      i_awburst_nxt;
reg    [2-1:0]      i_awburst_r;
reg    [4-1:0]      i_awcache_nxt;
reg    [4-1:0]      i_awcache_r;
reg                          i_awvalid_nxt;
reg                          i_awvalid_r;
reg    [32-1:0]       i_araddr_nxt;
reg    [32-1:0]       i_araddr_r;
reg    [4-1:0]        i_arlen_nxt;
reg    [4-1:0]        i_arlen_r;
reg    [3-1:0]       i_arsize_nxt;
reg    [3-1:0]       i_arsize_r;
reg    [2-1:0]      i_arburst_nxt;
reg    [2-1:0]      i_arburst_r;
reg    [4-1:0]      i_arcache_nxt;
reg    [4-1:0]      i_arcache_r;
reg    [2-1:0]       i_arlock_nxt;
reg    [2-1:0]       i_arlock_r;
reg                          i_arvalid_nxt;
reg                          i_arvalid_r;
reg                          i_rready_nxt;
reg                          i_rready_r;
reg    [32-1:0]       i_wdata_nxt;
reg    [32-1:0]       i_wdata_r;
reg    [(32/8)-1:0]   i_wstrb_nxt;
reg    [(32/8)-1:0]   i_wstrb_r;
reg                          i_wlast_nxt;
reg                          i_wlast_r;
reg                          i_wvalid_nxt;
reg                          i_wvalid_r;
reg    [32-1:0]       i_wdata_top_nxt;
reg    [32-1:0]       i_wdata_top_r;
reg                          i_eop_top_nxt;
reg                          i_eop_top_r;
reg                          i_tend_nxt;      // transaction end
reg                          i_tend_r;
reg                          i_rlast_nxt;
reg                          i_rlast_r;
reg                          i_ack_nxt;
reg                          i_ack_r;
reg                          i_bready_nxt;
reg                          i_bready_r;

// BVCI registers
//
reg                          i_t_cmdack_nxt;
reg                          i_t_cmdack_r;
reg                          i_t_rspval_nxt;
reg                          i_t_rspval_r;
reg                          i_t_reop_nxt;
reg                          i_t_reop_r;
reg    [32-1:0]       i_t_rdata_nxt;
reg    [32-1:0]       i_t_rdata_r;
reg                          i_t_rerror_nxt;
reg                          i_t_rerror_r;

// FSM state
//
reg    [2:0]                 i_state_r;
reg    [2:0]                 i_state_nxt;

wire                         i_unsupported_a;
wire ap_addr_wen;
wire ap_data_wen;
wire ap_cmd_wen;


assign ap_addr_wen = bvci_write && (t_address[11:0] == AXI_ADDR);
assign ap_data_wen = bvci_write && (t_address[11:0] == AXI_DATA);
assign ap_cmd_wen  = bvci_write && (t_address[11:0] == AXI_CMD);

always@(posedge clk or posedge rst_a)
begin
   if(rst_a == 1'b1)
   begin //{
     axi_addr <= 32'b0;
     axi_data <= 32'b0;
     axi_cmd  <= 32'b0;
     //axi_rom_sel = 1'b0;
   end //}
   else
   begin //{ 
     if (ap_addr_wen) axi_addr  <= axi_addr_nxt;
     if (ap_data_wen) axi_data  <= axi_data_nxt;
     if (ap_cmd_wen)  axi_cmd   <= axi_cmd_nxt;
     //axi_rom_sel  = axi_rom_sel_nxt;
   end //}
end

//  asynchronous part of FSM
//
always @(
  i_awaddr_r      or
  i_awlen_r       or
  i_awsize_r      or
  i_awburst_r     or
  i_awcache_r     or
  i_awvalid_r     or
  i_araddr_r      or
  i_arlen_r       or
  i_arsize_r      or
  i_arburst_r     or
  i_arcache_r     or
  i_arlock_r      or
  i_arvalid_r     or
  i_rready_r      or
  i_wdata_r       or
  i_wstrb_r       or
  i_wlast_r       or
  i_wvalid_r      or
  i_bready_r      or
  i_t_rdata_r     or
  i_t_rerror_r    or
  i_t_reop_r      or
  i_t_cmdack_r    or
  i_t_rspval_r    or
  t_be            or
  t_eop           or
  t_address       or
  t_wdata         or
  i_bvci_cmd_a    or
  i_wdata_top_r   or
  i_eop_top_r     or
  i_tend_r        or
  i_rlast_r       or
  i_ack_r         or
  bri_awready     or
  bri_wready      or
  bri_arready     or
  bri_bvalid      or
  bri_bresp       or
  bri_bid         or
  bri_rid         or
  bri_rvalid      or
  bri_rresp       or
  bri_rdata       or
  bri_rlast       or
  i_axi_write_a   or
  i_axi_len_a     or
  i_axi_size_a    or
  i_axi_rsize_a   or
  i_axi_burst_a   or
  i_axi_cache_a   or
  i_axi_lock_a    or
  i_axi_raddr_a   or
  i_unsupported_a or
  i_state_r)

  begin : ASYNC_FSM_PROC

  // keep current values unless explicitly updated later
  // in this block
  //
  i_awaddr_nxt      = i_awaddr_r;
  i_awlen_nxt       = i_awlen_r;
  i_awsize_nxt      = i_awsize_r;
  i_awburst_nxt     = i_awburst_r;
  i_awcache_nxt     = i_awcache_r;
  i_awvalid_nxt     = i_awvalid_r;
  i_araddr_nxt      = i_araddr_r;
  i_arlen_nxt       = i_arlen_r;
  i_arsize_nxt      = i_arsize_r;
  i_arburst_nxt     = i_arburst_r;
  i_arcache_nxt     = i_arcache_r;
  i_arlock_nxt      = i_arlock_r;
  i_arvalid_nxt     = i_arvalid_r;
  i_rready_nxt      = i_rready_r;
  i_wdata_nxt       = i_wdata_r;
  i_wdata_top_nxt   = i_wdata_top_r;
  i_eop_top_nxt     = i_eop_top_r;
  i_tend_nxt        = i_tend_r;
  i_rlast_nxt       = i_rlast_r;
  i_ack_nxt         = i_ack_r;
  i_wstrb_nxt       = i_wstrb_r;
  i_wlast_nxt       = i_wlast_r;
  i_wvalid_nxt      = i_wvalid_r;
  i_bready_nxt      = i_bready_r;
  i_t_rdata_nxt     = i_t_rdata_r;
  i_t_rerror_nxt    = i_t_rerror_r;
  i_t_reop_nxt      = i_t_reop_r;
  i_t_cmdack_nxt    = i_t_cmdack_r;
  i_t_rspval_nxt    = i_t_rspval_r;
  i_state_nxt       = i_state_r;

  case (i_state_r)

  // -------------- //
  // FSM IDLE state //
  // -------------- //
  0:
    begin
    i_t_reop_nxt   = 1'b 0;
    i_t_rspval_nxt = 1'b 0;
    i_t_rerror_nxt = 1'b 0;
    if (i_bvci_cmd_a == 1'b 1)
      begin
      if (i_axi_write_a == 1'b 1)
        begin
        i_t_rerror_nxt = i_unsupported_a;
        i_t_cmdack_nxt = ~t_eop;
        i_t_rspval_nxt = ~t_eop;
          i_awaddr_nxt = {t_address[32-1:2],{2'b 0}};
//%%addif_64_interface%%        i_awaddr_nxt = {t_address[32-1:3],{3'b 0}};
        i_awlen_nxt    = i_axi_len_a;
        i_awsize_nxt   = i_axi_size_a;
        i_awburst_nxt  = i_axi_burst_a;
        i_awcache_nxt  = i_axi_cache_a;
        i_awvalid_nxt  = 1'b 1;
        i_arlock_nxt   = 2'b 00;
        i_wvalid_nxt   = 1'b 1;
        i_wdata_nxt    = t_wdata;
        i_wstrb_nxt    = t_be;
        i_wlast_nxt    = t_eop;
        i_bready_nxt   = t_eop;
        i_state_nxt    = 1;
        end
      else
        begin
        i_t_rerror_nxt = i_unsupported_a;
        i_t_cmdack_nxt = ~t_eop;
        i_t_rspval_nxt = 1'b 0;
        i_araddr_nxt   = i_axi_raddr_a;
        i_arlen_nxt    = i_axi_len_a;
        i_arsize_nxt   = i_axi_rsize_a;
        i_arburst_nxt  = i_axi_burst_a;
        i_arcache_nxt  = i_axi_cache_a;
        i_arlock_nxt   = i_axi_lock_a;
        i_arvalid_nxt  = 1'b 1;
        i_rlast_nxt    = t_eop;
        i_tend_nxt     = t_eop;
        i_state_nxt    = 4;
        end
      end
    else
      begin
      i_t_cmdack_nxt = 1'b 1;
      end
    end

  // ---------------- //
  // FSM1 WRITE state //
  // ---------------- //
  1:
    begin
    if ((bri_awready == 1'b 1) & (i_awvalid_r == 1'b 1))
      begin
      i_awvalid_nxt = 1'b 0;
      end

    if (bri_wready == 1'b 1)
      begin
      if (i_wlast_r == 1'b 1)
        begin
        i_wlast_nxt  = 1'b 0;
        i_wvalid_nxt = 1'b 0;
        if ((bri_bvalid  == 1'b 1 ) & 
            (bri_bid     == ID_TAG) &
            (i_awvalid_r == 1'b 0) )
          begin
          i_t_cmdack_nxt = 1'b 1;
          i_t_rspval_nxt = 1'b 1;
          i_t_rerror_nxt = (bri_bresp != 0);
          i_t_reop_nxt   = 1'b 1;
          i_bready_nxt   = 1'b 0;
          i_state_nxt    = 0;
          end
        else
          begin
          i_t_cmdack_nxt = 1'b 0;
          i_t_rspval_nxt = 1'b 0;
          i_state_nxt    = 3;
          end
        end
      else
        begin
        i_t_cmdack_nxt  = ~t_eop;
        i_t_rspval_nxt  = ~t_eop;
        i_wdata_nxt     = t_wdata;
        i_wlast_nxt     = t_eop;
        i_bready_nxt    = t_eop;
       end
      end
    else
      begin
      i_t_cmdack_nxt  = 1'b 0;
      i_t_rspval_nxt  = 1'b 0;
      if (i_wlast_r == 1'b 0)
        begin
        i_eop_top_nxt   = t_eop;
        i_wdata_top_nxt = t_wdata;
        i_state_nxt     = 2;
        end
      end
    end

  // ---------------- //
  // FSM2 WRITE state //
  // ---------------- //
  2:
    begin
    if ((bri_awready == 1'b 1) & (i_awvalid_r == 1'b 1))
      begin
      i_awvalid_nxt = 1'b 0;
      end

    if (bri_wready == 1'b 1)
      begin
      i_t_cmdack_nxt  = ~i_eop_top_r;
      i_t_rspval_nxt  = ~i_eop_top_r;
      i_wdata_nxt     = i_wdata_top_r;
      i_wlast_nxt     = i_eop_top_r;
      i_bready_nxt    = i_eop_top_r;
      i_state_nxt     = 1;
      end
    end

  // ---------------- //
  // FSM3 WRITE state //
  // ---------------- //
  3:
    begin
    if ((bri_awready == 1'b 1) & (i_awvalid_r == 1'b 1))
      begin
      i_awvalid_nxt = 1'b 0;
      end

    if ((bri_bvalid == 1'b 1 ) & 
        (bri_bid    == ID_TAG) &
        (i_awvalid_r == 1'b 0) )
       begin
       i_t_cmdack_nxt = 1'b 1;
       i_t_rspval_nxt = 1'b 1;
       i_t_rerror_nxt = (bri_bresp != 0);
       i_t_reop_nxt   = 1'b 1;
       i_bready_nxt   = 1'b 0;
       i_state_nxt    = 0;
       end
     end

  // -------------- //
  // FSM READ state //
  // -------------- //
  4:
    begin

    if ((i_rlast_r == 1'b 1) |
        (t_eop     == 1'b 1) |
        (i_tend_r  == 1'b 1) )
      begin
      i_tend_nxt     = 1'b 1;
      i_t_cmdack_nxt = 1'b 0;
      end
    else
      begin
      i_t_cmdack_nxt = 1'b 1;
      end

    if ((bri_arready == 1'b 1) & (i_arvalid_r == 1'b 1))
      begin
      i_rready_nxt   = 1'b 1;
      i_arvalid_nxt =  1'b 0;
      end

    if ((bri_rvalid == 1'b 1) & 
        (bri_rid    == ID_TAG) &
        (i_rready_r == 1'b 1))
      begin
      i_t_rdata_nxt  = bri_rdata;
      i_t_reop_nxt   = bri_rlast;
      i_t_rspval_nxt = 1'b 1;
      i_t_rerror_nxt = (bri_rresp != 0);
      if (bri_rlast == 1'b 1)
        begin
        i_tend_nxt     = 1'b 0;
        i_t_cmdack_nxt = 1'b 1;
        i_rready_nxt   = 1'b 0;
        i_state_nxt    = 0;
        end
      end
    else
      begin
      i_t_rspval_nxt = 1'b 0;
      end
    end

  // ----------------- //
  // FSM DEFAULT state //
  // ----------------- //
  default:
    begin
    i_state_nxt = 0;
    end

  endcase
  end // block: ASYNC_FSM_PROC
   
// synchronous part of FSM
//
always @(posedge clk or posedge rst_a)
  begin : SYNC_FSM_PROC
  if (rst_a == 1'b 1)
    begin
    i_awaddr_r      <= {(32)     {1'b 0}};
    i_awlen_r       <= {(4)      {1'b 0}};
    i_awsize_r      <= {(3)     {1'b 0}};
    i_awburst_r     <= {(2)    {1'b 0}};
    i_awcache_r     <= {(4)    {1'b 0}};
    i_awvalid_r     <=                   1'b 0;
    i_araddr_r      <= {(32)     {1'b 0}};
    i_arlen_r       <= {(4)      {1'b 0}};
    i_arsize_r      <= {(3)     {1'b 0}};
    i_arburst_r     <= {(2)    {1'b 0}};
    i_arcache_r     <= {(4)    {1'b 0}};
    i_arlock_r      <= {(2)     {1'b 0}};
    i_arvalid_r     <=                   1'b 0;
    i_rready_r      <=                   1'b 0;
    i_wdata_r       <= {(32)     {1'b 0}};
    i_wdata_top_r   <= {(32)     {1'b 0}};
    i_eop_top_r     <=                   1'b 0;
    i_tend_r        <=                   1'b 0;
    i_rlast_r       <=                   1'b 0;
    i_ack_r         <=                   1'b 0;
    i_wstrb_r       <= {(32/8)   {1'b 0}};
    i_wlast_r       <=                   1'b 0;
    i_wvalid_r      <=                   1'b 0;
    i_bready_r      <=                   1'b 0;
    i_t_rdata_r     <= {(32)     {1'b 0}};
    i_t_rerror_r    <=                   1'b 0;
    i_t_reop_r      <=                   1'b 0;
    i_t_cmdack_r    <=                   1'b 0;
    i_t_rspval_r    <=                   1'b 0;
    i_state_r       <= 0;
    end
  else
    begin
    //  update the FSM flipflops with new values from
    //  the async part of FSM.
    //
    i_awaddr_r      <= i_awaddr_nxt;
    i_awlen_r       <= i_awlen_nxt;
    i_awsize_r      <= i_awsize_nxt;
    i_awburst_r     <= i_awburst_nxt;
    i_awcache_r     <= i_awcache_nxt;
    i_awvalid_r     <= i_awvalid_nxt;
    i_araddr_r      <= i_araddr_nxt;
    i_arlen_r       <= i_arlen_nxt;
    i_arsize_r      <= i_arsize_nxt;
    i_arburst_r     <= i_arburst_nxt;
    i_arcache_r     <= i_arcache_nxt;
    i_arlock_r      <= i_arlock_nxt;
    i_arvalid_r     <= i_arvalid_nxt;
    i_rready_r      <= i_rready_nxt;
    i_wdata_r       <= i_wdata_nxt;
    i_wdata_top_r   <= i_wdata_top_nxt;
    i_eop_top_r     <= i_eop_top_nxt;
    i_tend_r        <= i_tend_nxt;
    i_rlast_r       <= i_rlast_nxt;
    i_ack_r         <= i_ack_nxt;
    i_wstrb_r       <= i_wstrb_nxt;
    i_wlast_r       <= i_wlast_nxt;
    i_wvalid_r      <= i_wvalid_nxt;
    i_bready_r      <= i_bready_nxt;
    i_t_rdata_r     <= i_t_rdata_nxt;
    i_t_rerror_r    <= i_t_rerror_nxt;
    i_t_reop_r      <= i_t_reop_nxt;
    i_t_cmdack_r    <= i_t_cmdack_nxt;
    i_t_rspval_r    <= i_t_rspval_nxt;
    i_state_r       <= i_state_nxt;
    end
  end // block: SYNC_FSM_PROC

// Drive control signals from inputs
//
assign i_odd16_a     = (t_plen == 9'b 10) && (t_address[0] != 1'b 0);
   assign i_unsupported_a = ((t_plen > 9'b 100)  &&
                             (~(t_be[0] & t_be[1] &
                               t_be[2] & t_be[2]))) ||
                            (t_plen > 9'b 1000000);
   assign i_axi_size_a  = 2;
   assign i_length_a    =  t_plen[6:2] - 5'b 00001;
   assign i_axi_len_a   = (t_plen[6:2] == 5'b 00000) ? 
                           4'b 0000: i_length_a[3:0];
   assign i_axi_burst_a = (((ID_TAG == 1) ||
                            (ID_TAG == 2))              &&
                           (((i_axi_len_a    == 3 ) &&
                             (t_address[3:2] != 2'b 00     )  ) ||
                            ((i_axi_len_a    == 7 ) &&
                             (t_address[4:2] != 3'b 000    )  ) ||
                            ((i_axi_len_a    == 15) &&
                             (t_address[5:2] != 4'b 0000   )  )))?
                         2 : 1;
   assign i_axi_rsize_a =  (t_plen == 9'b 000000001) ? 0:
                          ((t_plen == 9'b 000000010) && 
                           (i_odd16_a == 1'b 0))     ? 1:
                          2;
   assign i_axi_raddr_a =(i_axi_rsize_a == 0 )? 
                           {t_address}:
                         (i_axi_rsize_a == 1)? 
                           {t_address[32-1:1],1'b 0}:
                           {t_address[32-1:2],2'b 0};
assign i_axi_cache_a = (t_eop == 1'b 1) ? 0 : 
                       15;
assign i_axi_prot_a  = 0;
assign i_axi_id_a    = ID_TAG;
assign i_axi_write_a = (t_cmd == 2) ? 1'b 1 : 1'b 0 ;
assign i_axi_lock_a  = (t_cmd == 3) ? 2'b 10 : 2'b 00 ;
assign i_bvci_cmd_a  = t_cmdval & sync;
/////////////////////////////////////////////////////////


//assign axi_addr = (t_address == DB_ADDR)? t_wdata : 32'h0 ;
//assign axi_data = (t_address == DB_DATA)? t_wdata : 32'h0 ;
//assign axi_cmd = (t_address == DB_CMD) ? t_wdata :32'h0;

//always@*
//begin
//	if(t_address == DB_ADDR)	
//		axi_addr = t_wdata;
//	if(t_address == DB_DATA)
//		axi_data = t_wdata;
//	if(t_address == DB_CMD)
//		axi_cmd = t_wdata;
//end

//always @*
//begin : axi_rom_sel_PROC
//	if(axi_addr[31:12] == `AXI_ROM_SPACE)
//	begin
//		axi_rom_sel_nxt = 1;
//	end
//	else if ((axi_rom_sel_nxt ==1) && (t_address[11:0] == AXI_STATUS))
//	begin
//		axi_rom_sel_nxt = 0;
//	end
//	
//end
///Rom Table of AXI ///
always@*
begin: rom_table_PROC
  rom_rdata = 32'b0;
  if (my_select == 4'b1) //(axi_rom_sel)
  begin
    casez(axi_addr[11:0])
    12'h000: 
    begin
      rom_rdata = {20'hFFFF9, //0080, // [31:12] entry offset
                  3'b0, // [11:9] reserv
                  5'd0, // [8:4] pwrid
                  1'b0, // [3] reserv
                  1'b0, // [2] pwrvld
                  1'b1, // [1] 32-bit format
                  1'b1  // [0] present 
                  };
    end
   12'h004: 
    begin
      rom_rdata = {20'h0, //20000, // [31:12] entry offset
                  3'b0, // [11:9] reserv
                  5'd0, // [8:4] pwrid
                  1'b0, // [3] reserv
                  1'b0, // [2] pwrvld
                  1'b0, // [1] 32-bit format
                  1'b0  // [0] present 
                  };
    end
    12'h400: rom_rdata = {24'h0,8'h10}; // [7:4] Component class (0x1 Rom Table) [3:0] Preamble 1 (0x0)
    12'hFCC: rom_rdata = 32'b0; // memory_type
    12'hFD0: rom_rdata = {24'h0,8'h04}; // PIDR4 // [7:4] size // [3:0] DES_2
    12'hFD4: rom_rdata = {24'h0,8'h00}; // PIDR5 // reserv
    12'hFD8: rom_rdata = {24'h0,8'h00}; // PIDR6 // reserv
    12'hFDC: rom_rdata = {24'h0,8'h00}; // PIDR7 // reserv
    12'hFE0: rom_rdata = {24'h0,8'h01}; // PIDR0 // [7:0] Part number bits
    12'hFE4: rom_rdata = {24'h0,8'h80}; // PIDR1 // [7:4] JEP106 identification code bits[3:0] // [3:0] Part number bits[11:8]
    12'hFE8: rom_rdata = {24'h0,8'h0D}; // PIDR2 // [7:4] Revision // [3] JEDEC // [2:0] JEP106 identification code[6:4]
    12'hFEC: rom_rdata = {24'h0,8'h00}; // PIDR3 // [7:4] RevAnd // [3:0] Customer Modified
    12'hFF0: rom_rdata = {24'h0,8'h0D}; // CIDR0 // [7:0] Preamble 0 (0x0D)
    12'hFF4: rom_rdata = {24'h0,8'h10}; // CIDR1 // [7:4] Component class (0x1 ��� Class 0x1 Rom Table) [3:0] Preamble 1 (0x0)
    12'hFF8: rom_rdata = {24'h0,8'h05}; // CIDR2 // [7:0] Preamble 2 (0x05)
    12'hFFC: rom_rdata = {24'h0,8'hB1}; // CIDR3 // [7:0] Preamble 3 (0xB1)
    default: rom_rdata = 32'b0;                      
    endcase
  end
end // rom_table_PROC

/////////////for rspval; should be copied to above///////
  reg                         rspval_r;         // rspval state variable
  reg                         rspval_nxt; 
  
  always @*
  begin : rspval_nxt_PROC
  rspval_nxt =   (    t_cmdval    )  ;
              //|  (   rspval_r & (~t_rspack));
  end 
  
  always @(posedge clk or posedge rst_a)
  begin : db_state_PROC
    if (rst_a == 1'b1)
      begin
      rspval_r      <=  1'b0;
      end
    else
      begin
      rspval_r      <=  rspval_nxt;
      end
  end
  
  //////////rerr;should be copied to above/////////
reg                         db_addr_match;    // 1 if no address match

reg                         db_addr_err;      // 1 if unmatched access
reg                         db_cmd_err;       // 1 if illegal cmd given
reg                         db_read_err;      // 1 if read from reset reg
reg                         db_be_err;        // 1 if some BE bits not set
reg rerr_nxt;
reg rerr_r;
always@*
begin
  db_addr_match = (t_address[11:0] == AXI_STATUS)|(t_address[11:0] == AXI_CMD)|  
                  (t_address[11:0] == AXI_ADDR)|(t_address[11:0] == AXI_DATA)|
                  (t_address[11:0] == AXI_RESET)| (t_address[11:0] == AXI_CSR1)|
                  (t_address[11:0] == AXI_CSR2)| (t_address[11:0] == AXI_CSR3)|
                  (t_address[11:0] == AXI_CSR4)| (t_address[11:0] == AXI_CSR5);
  db_cmd_err     = t_cmdval & (~(bvci_read | bvci_write));
  db_addr_err   = t_cmdval & (~db_addr_match);
  db_be_err      = t_cmdval & (~(&t_be));
  db_read_err  = (t_address == AXI_RESET) ? bvci_read : 1'b0;
  rerr_nxt      =   (   db_addr_err
                           | db_cmd_err
                           | db_read_err
                           | db_be_err
                         );// |  (   rerr_r & (~t_rspack));
end

  always @(posedge clk or posedge rst_a)
  begin : rerr_r_PROC
    if (rst_a == 1'b1)
    begin
      rerr_r <= 1'b0;
    end
    else
    begin
      rerr_r <= rerr_nxt;
    end
  end 
///////////////////////////////////////////////////
///register file of AXI ////
always @*
  begin //{
    bvci_read = t_cmdval & (t_cmd == `BVCI_CMD_RD);
    bvci_write = t_cmdval & (t_cmd == `BVCI_CMD_WR);
    
    axi_addr_nxt = axi_addr;
    axi_data_nxt = axi_data;
    axi_cmd_nxt  = 32'b0;
    if(bvci_read)
    begin //{
      case(t_address[11:0])
        AXI_STATUS: //read-only
          axiap_rdata = 32'h24;
        AXI_CMD:
          axiap_rdata = axi_cmd;
        AXI_ADDR:
          axiap_rdata = axi_addr;
        AXI_DATA:
          axiap_rdata = i_axi_data; //axi_data should be updated to include rom_rdata also
        //AXI_RESET:
        AXI_CSR1: //read-only
          axiap_rdata = 32'h90; // 31:8- reserved ; 7:0 - class
        AXI_CSR2: //read-only
          axiap_rdata = 32'h14B0_0004; 
        AXI_CSR3: //read-only
          axiap_rdata = 32'h0; //2- LD; 1-LA
        AXI_CSR4: //read-only
          axiap_rdata = `AXI_ROM_BASE_ADDR;
	      AXI_CSR5: //read-only
          axiap_rdata = `AXI_ROM_UPPER_BASE_ADDR;
        12'hFBC: axiap_rdata = {11'h258,1'b1,4'h1,16'h0301};  // DEVARCH
        12'hFC0: axiap_rdata = 32'h0000000;           // DEVID2
        12'hFC4: axiap_rdata = 32'h0000000;           // DEVID1
        12'hFC8: axiap_rdata = 32'h0000021;           // DEVID
        12'hFCC: axiap_rdata = {24'h000000, 8'h00};   // DEVTYPE Other Misc
	12'hFD0: axiap_rdata = {24'h000000, 8'h04};   // PIDR4
	12'hFD4: axiap_rdata = {24'h000000, 8'h00};   // PIDR5
	12'hFD8: axiap_rdata = {24'h000000, 8'h00};   // PIDR6
	12'hFDC: axiap_rdata = {24'h000000, 8'h00};   // PIDR7
	12'hFE0: axiap_rdata = {24'h000000, 8'h01};   // PIDR0
	12'hFE4: axiap_rdata = {24'h000000, 8'h80};   // PIDR1
	12'hFE8: axiap_rdata = {24'h000000, 8'h0D};   // PIDR2
	12'hFEC: axiap_rdata = {24'h000000, 8'h00};   // PIDR3
	12'hFF0: axiap_rdata = {24'h000000, 8'h0D};   // CIDR0
	12'hFF4: axiap_rdata = {24'h000000, 8'h90};   // CIDR1
	12'hFF8: axiap_rdata = {24'h000000, 8'h05};   // CIDR2
	12'hFFC: axiap_rdata = {24'h000000, 8'hB1};   // CIDR3
	default: axiap_rdata = 32'b0;
      endcase
    end //}
    else axiap_rdata = 32'b0;


    if(bvci_write)
    begin //{
      if(t_address[11:0] == AXI_ADDR)	
		    axi_addr_nxt = t_wdata;
	    if(t_address[11:0] == AXI_DATA)
		    axi_data_nxt = t_wdata;
	    if(t_address[11:0] == AXI_CMD)
		    axi_cmd_nxt = t_wdata;
    end //}

  end //}
  
assign axi_cmdack = t_cmdval; //how to generate this cmd_ack? nd rspval, rerr?
assign axi_reop = rspval_r;
assign axi_rspval = rspval_r;
assign axi_rerr = rerr_r;
/////////////////////////////////////////////////////////
//  Bridge outputs
//
assign t_cmdack = (my_select == 4'b0) ? axi_cmdack : (i_t_cmdack_r & sync);
assign t_rspval = (my_select == 4'b0) ? axi_rspval:(i_t_rspval_r & sync);
assign t_reop   = (my_select == 4'b0) ? axi_reop:(i_t_reop_r   & sync);
assign t_rerror = (my_select == 4'b1)? 1'b0:
		  (my_select == 4'b0) ? axi_rerr: (i_t_rerror_r & sync);
assign t_rdata = i_axi_data;
assign i_axi_data = (my_select == 4'b1)? rom_rdata:
        	   (my_select == 4'b0) ? axi_data:  i_t_rdata_r;
 
//assign t_rdata  = (my_select == 4'b1)? rom_rdata:
//        	   (my_select == 4'b0) ? axiap_rdata:  i_t_rdata_r;


assign bri_awid     = i_axi_id_a;                    // constant
assign bri_wid      = i_axi_id_a;                    // constant
assign bri_arid     = i_axi_id_a;                    // constant
assign bri_awprot   = i_axi_prot_a;                  // constant
assign bri_arprot   = i_axi_prot_a;                  // constant
assign bri_awaddr   = i_awaddr_r;
assign bri_awlen    = i_awlen_r;
assign bri_awsize   = i_awsize_r;
assign bri_awburst  = i_awburst_r;
assign bri_awlock   = 1'b 0;
assign bri_awcache  = i_awcache_r;
assign bri_awvalid  = i_awvalid_r;
assign bri_wlast    = i_wlast_r;
assign bri_wvalid   = i_wvalid_r;
assign bri_wdata    = i_wdata_r;
assign bri_wstrb    = i_wstrb_r;
assign bri_bready   = i_bready_r;
assign bri_araddr   = i_araddr_r;
assign bri_arlen    = i_arlen_r;
assign bri_arsize   = i_arsize_r;
assign bri_arburst  = i_arburst_r;
assign bri_arlock   = i_arlock_r;
assign bri_arcache  = i_arcache_r;
assign bri_arvalid  = i_arvalid_r;
assign bri_rready   = i_rready_r;

assign bri_busy = ((i_state_r == 0) && 
                   (i_t_rspval_r == 1'b 0) && !i_bvci_cmd_a) ? 1'b 0 : 1'b 1; 

endmodule // module bvci_to_axi
